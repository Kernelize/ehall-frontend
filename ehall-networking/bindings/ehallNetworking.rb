# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'


module EhallNetworking
  def self.uniffi_in_range(i, type_name, min, max)
  raise TypeError, "no implicit conversion of #{i} into Integer" unless i.respond_to?(:to_int)
  i = i.to_int
  raise RangeError, "#{type_name} requires #{min} <= value < #{max}" unless (min <= i && i < max)
  i
end

def self.uniffi_utf8(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v = v.to_str.encode(Encoding::UTF_8)
  raise Encoding::InvalidByteSequenceError, "not a valid UTF-8 encoded string" unless v.valid_encoding?
  v
end

def self.uniffi_bytes(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v.to_str
end

  class RustBuffer < FFI::Struct
  layout :capacity, :int32,
         :len,      :int32,
         :data,     :pointer

  def self.alloc(size)
    return EhallNetworking.rust_call(:ffi_ehall_networking_rustbuffer_alloc, size)
  end

  def self.reserve(rbuf, additional)
    return EhallNetworking.rust_call(:ffi_ehall_networking_rustbuffer_reserve, rbuf, additional)
  end

  def free
    EhallNetworking.rust_call(:ffi_ehall_networking_rustbuffer_free, self)
  end

  def capacity
    self[:capacity]
  end

  def len
    self[:len]
  end

  def len=(value)
    self[:len] = value
  end

  def data
    self[:data]
  end

  def to_s
    "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
  end

  # The allocated buffer will be automatically freed if an error occurs, ensuring that
  # we don't accidentally leak it.
  def self.allocWithBuilder
    builder = RustBufferBuilder.new

    begin
      yield builder
    rescue => e
      builder.discard
      raise e
    end
  end

  # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
  # leak it even if an error occurs.
  def consumeWithStream
    stream = RustBufferStream.new self

    yield stream

    raise RuntimeError, 'junk data left in buffer after consuming' if stream.remaining != 0
  ensure
    free
  end# The primitive String type.

  def self.allocFromString(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write value.encode('utf-8')
      return builder.finalize
    end
  end

  def consumeIntoString
    consumeWithStream do |stream|
      return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
    end
  end

  
end

module UniFFILib
  class ForeignBytes < FFI::Struct
    layout :len,      :int32,
           :data,     :pointer

    def len
      self[:len]
    end

    def data
      self[:data]
    end

    def to_s
      "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
    end
  end
end

private_constant :UniFFILib
  
# Helper for structured reading of values from a RustBuffer.
class RustBufferStream

  def initialize(rbuf)
    @rbuf = rbuf
    @offset = 0
  end

  def remaining
    @rbuf.len - @offset
  end

  def read(size)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    data = @rbuf.data.get_bytes @offset, size

    @offset += size

    data
  end

  def readU64
    unpack_from 8, 'Q>'
  end

  def readString
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative string length' if size.negative?

    read(size).force_encoding(Encoding::UTF_8)
  end

  

  def unpack_from(size, format)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    value = @rbuf.data.get_bytes(@offset, size).unpack format

    @offset += size

    # TODO: verify this
    raise 'more than one element!!!' if value.size > 1

    value[0]
  end
end

private_constant :RustBufferStream
  
# Helper for structured writing of values into a RustBuffer.
class RustBufferBuilder
  def initialize
    @rust_buf = RustBuffer.alloc 16
    @rust_buf.len = 0
  end

  def finalize
    rbuf = @rust_buf

    @rust_buf = nil

    rbuf
  end

  def discard
    return if @rust_buf.nil?

    rbuf = finalize
    rbuf.free
  end

  def write(value)
    reserve(value.bytes.size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
    end
  end

  def write_U64(v)
    v = EhallNetworking::uniffi_in_range(v, "u64", 0, 2**64)
    pack_into(8, 'Q>', v)
  end

  def write_String(v)
    v = EhallNetworking::uniffi_utf8(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  

  private

  def reserve(num_bytes)
    if @rust_buf.len + num_bytes > @rust_buf.capacity
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes)
    end

    yield

    @rust_buf.len += num_bytes
  end

  def pack_into(size, format, value)
    reserve(size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
    end
  end
end

private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
  layout :code,    :int8,
         :error_buf, RustBuffer

  def code
    self[:code]
  end

  def error_buf
    self[:error_buf]
  end

  def to_s
    "RustCallStatus(code=#{self[:code]})"
  end
end

# These match the values from the uniffi::rustcalls module
CALL_SUCCESS = 0
CALL_ERROR = 1
CALL_PANIC = 2

# Map error modules to the RustBuffer method name that reads them
ERROR_MODULE_TO_READER_METHOD = {
}

private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                 :RustCallStatus

def self.consume_buffer_into_error(error_module, rust_buffer)
  rust_buffer.consumeWithStream do |stream|
    reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
    return stream.send(reader_method)
  end
end

class InternalError < StandardError
end

def self.rust_call(fn_name, *args)
  # Call a rust function
  rust_call_with_error(nil, fn_name, *args)
end

def self.rust_call_with_error(error_module, fn_name, *args)
  # Call a rust function and handle errors
  #
  # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.


  # Note: RustCallStatus.new zeroes out the struct, which is exactly what we
  # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
  # data=NULL))
  status = RustCallStatus.new
  args << status

  result = UniFFILib.public_send(fn_name, *args)

  case status.code
  when CALL_SUCCESS
    result
  when CALL_ERROR
    if error_module.nil?
      status.error_buf.free
      raise InternalError, "CALL_ERROR with no error_module set"
    else
      raise consume_buffer_into_error(error_module, status.error_buf)
    end
  when CALL_PANIC
    # When the rust code sees a panic, it tries to construct a RustBuffer
    # with the message.  But if that code panics, then it just sends back
    # an empty buffer.
    if status.error_buf.len > 0
      raise InternalError, status.error_buf.consumeIntoString()
    else
      raise InternalError, "Rust panic"
    end
  else
    raise InternalError, "Unknown call status: #{status.code}"
  end
end

private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
module UniFFILib
  extend FFI::Library

  
  ffi_lib 'uniffi_ehallNetworking'
  

  attach_function :uniffi_ehall_networking_fn_func_rust_add,
    [:uint64, :uint64, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_ehall_networking_fn_func_rust_greeting,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_ehall_networking_fn_func_rust_tokio_test,
    [RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_ehall_networking_rustbuffer_alloc,
    [:int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_ehall_networking_rustbuffer_from_bytes,
    [ForeignBytes, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_ehall_networking_rustbuffer_free,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_ehall_networking_rustbuffer_reserve,
    [RustBuffer.by_value, :int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_ehall_networking_checksum_func_rust_add,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_ehall_networking_checksum_func_rust_greeting,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_ehall_networking_checksum_func_rust_tokio_test,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :ffi_ehall_networking_uniffi_contract_version,
    [RustCallStatus.by_ref],
    :uint32
  
end

  # Public interface members begin here.

  

  
  

def self.rust_add(left, right)
    left = EhallNetworking::uniffi_in_range(left, "u64", 0, 2**64)
    
    
    right = EhallNetworking::uniffi_in_range(right, "u64", 0, 2**64)
    
    
  result = EhallNetworking.rust_call(:uniffi_ehall_networking_fn_func_rust_add,left,right)
  return result.to_i
end


  
  

def self.rust_greeting(name)
    name = EhallNetworking::uniffi_utf8(name)
    
    
  result = EhallNetworking.rust_call(:uniffi_ehall_networking_fn_func_rust_greeting,RustBuffer.allocFromString(name))
  return result.consumeIntoString
end


  
  

def self.rust_tokio_test()
  result = EhallNetworking.rust_call(:uniffi_ehall_networking_fn_func_rust_tokio_test,)
  return result.consumeIntoString
end


  

  
end

